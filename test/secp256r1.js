"use strict";

const verbose = false;

const assert = require("assert"); // node.js core module
const BigNumber = require('bignumber.js');
const EC = require('elliptic').ec;
const ec = new EC('p256');

const Secp256r1 = artifacts.require("Secp256r1");
const Ecsol = artifacts.require("Ecsol");

const pp = new BigNumber('FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF', 16);
const gx = new BigNumber('6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296', 16);
const gy = new BigNumber('4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5', 16);
const n = new BigNumber('FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551', 16);

const n2 = new BigNumber('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141', 16);

let toBigNumber = function(value) {
    if (!BigNumber.isBigNumber(value)) {
        return '0x'+value.toString(16)
    }
    return '0x'+value.toString(16);

}

function log(S) {
    if (verbose) {
        console.log("\t" + S);
    }
}

contract.only('Secp256r1.js', (accounts) => {

    let secp256r1;

    beforeEach('intialise contracts for testing', async function() {
        secp256r1 = await Secp256r1.new();
        let ecsol = await Ecsol.new();
    })

    describe('ECCurve Test', async () => {

        it('Should Add two big numbers', async () => {
            const ECADD_TEST_DATA = {
                "TEST_1": {
                    "input": ["d9e56176cf9b64d2d463285d4236ee6155a00877be3e42fbffd56dbf00b2667c", "497b83929bd210705aff0b98f29e5609920e5ff581240c6408caa43e4f1c2e43", "cc210ff32589e66ce5e1d7d6577e1312e88e62c40dd517bb787c39bc378c5f03", "4072f582dda39af4ffd418d90b1d85768dbe8516dbb511cb3bdf205325b40b4b"],
                    "output": ["cca24612b07e8f722a7676cbd50e44af0cd49b20de37ceca3a679b2c4ed80609", "1076a12233ce461be12b0b2edc343199e757490c63e041b0fa1c57413da59f13"]
                }
            };

            let fixture;
            for (var i in ECADD_TEST_DATA) {
                fixture = ECADD_TEST_DATA[i];

                const x1 = toBigNumber(new BigNumber(fixture['input'][0], 16));
                const y1 = toBigNumber(new BigNumber(fixture['input'][1], 16));
                
                const x2 = toBigNumber(new BigNumber(fixture['input'][2], 16));
                const y2 = toBigNumber(new BigNumber(fixture['input'][3], 16));

                const z1 = new BigNumber(1);
                const z2 = new BigNumber(1);

                console.log(x1)
                console.log(y1)
                console.log(x2)
                console.log(y2)

                const res = await secp256r1._ecAdd(x1, y1, z1, x2, y2, z2);
                console.log(res[0].toString(16), res[1].toString(16))
                assert.equal(res[0].toString(16), fixture['output'][0]);
                assert.equal(res[1].toString(16), fixture['output'][1]);
            }

        }); 

        it.only('Jacobian Addition', async () => {
            // Test data generated by golang crypto/elliptic library
            // var ECADD_TEST_DATA = require('./data/double-jacobian.json');
            var ECADD_TEST_DATA = {
                "TEST_1": {
                    "input": ["d9e56176cf9b64d2d463285d4236ee6155a00877be3e42fbffd56dbf00b2667c", "497b83929bd210705aff0b98f29e5609920e5ff581240c6408caa43e4f1c2e43", "1", "dd8b5ee06ff7c250486f2aa3e890c1117d22e3e17d15d72525a5c8422b7e019", "469d2d76935342f5d8d399f3474f32f814a4c843a53c834cd0adbe8ca82fbc67", "1"],
                    "output": ["866ee6c59a01c46ed398f8c4fe7a7e732264de9b3fae032bbc55bcba8e1b0265", "345d33e0c4ced6db57f58f9704b896340a747702ea24f64a1e3863e50dbc46d5", "67e6a8ec6ec82ea660479499f8a43b5f84644b8eb32634eca509dd8a440af338"]
                },
                "test1":{
                    "input":["759e8db1d416e42983aa346f21423522ed4491b57ce97d06d3c95a351c7ca927","2304fc7db349684ced981fe55c6ea140c5df98d49fde65042c1e6ce355e058d","1","29c681d2394a06f7a5fd892b59410a7232f5787e16a8249132de3510695d00f1","78d795dc4ca0a6d67926718477230448662f55859e712cf26b27aba6859ec105","1"],
                    "output":["1ad400df2a9769b7876b3c14c924e40b87ca436993ad9e16b6ebb1d017f2659c","14a3957950be22f4c0733b1ccb1db49eeb1e6766bb1ffa4585f35b2dedd26af4","684fe83fca66459d44a6a9786ffdaa9e8b61cd92337d4f14be29b5b699c0af93"]
                },
                "test2":{
                    "input":["5112831d340974a60be63d6388f29d1b916169c6c8dfa6b21348f314ffb5dbe6","42bc6c60ec8dfde03ebe50104c0829e6eac3dfc3df1d7dd000c7b88837149417","1","af482b49bb4ed836f36f397fd48d97521ba9f5c0a39174a280b22ecbc2adb532","600af32a0f9a8679cc9f8dcffb89517fc11741634f4a61b24f348a82196596fd","1"],
                    "output":["aa14a8aa0945cd35d9e134346ea2c71019c33ad140d044e96b6de3d0149bc1f9","450d5b0496d5dc79a6cc3cd8e09126ce264bd2680fddbe44fb2141f59107a99c","bc6b50590e8ac721cf11f8389735f46d149117f3b5639be0dad2776d85efb298"]
                },
                "test3":{
                    "input":["f52d3990974e5020fcc2bac67768c16ec521c76bd011e7b364327a506afce5b1","8ef2d22d86661bcceaf162a83948f86a01ff72e7ed0ccd87ed146950892fdf35","1","614c56e7286f6aedaa1c936ee36c0a5ee026482d7b1049bb88c39ebc92014ce1","6fd3cc0203c7a88657a118dd080f7644bf6f8e2c4a9c5114797e16d7ea6efebb","1"],
                    "output":["7db582394c35fecbae9cc1a069592a7dc002e637f0c195883d0e2d0eba8c7ce2","9e40524958adee3f67a813982036ceb559a0a28dd67d28fe794b73218ebdfe76","d83e3aab2242359b5ab3b150d80691e03609018555fcc410492248d84e08ce5e"]
                }
            };

            let fixture;
            for (var i in ECADD_TEST_DATA) {
                fixture = ECADD_TEST_DATA[i];

                // get inputs
                const x1 = toBigNumber(new BigNumber(fixture['input'][0], 16));
                const y1 = toBigNumber(new BigNumber(fixture['input'][1], 16));
                const z1 = toBigNumber(new BigNumber(fixture['input'][2], 16));
                const x2 = toBigNumber(new BigNumber(fixture['input'][3], 16));
                const y2 = toBigNumber(new BigNumber(fixture['input'][4], 16));
                const z2 = toBigNumber(new BigNumber(fixture['input'][5], 16));
                // expected outputs
                const x3 = toBigNumber(new BigNumber(fixture['output'][0], 16));
                const y3 = toBigNumber(new BigNumber(fixture['output'][1], 16));
                const z3 = toBigNumber(new BigNumber(fixture['output'][2], 16));

                let P = [x1, y1, z1, x2, y2, z2];

                let res = await secp256r1._jAdd(P[0], P[1], P[2], P[3], P[4], P[5]);
                // console.log(res)
                assert.equal(res[0].toString(16), x3.toString(10).slice(2));
                assert.equal(res[1].toString(16), y3.toString(10).slice(2));
                assert.equal(res[2].toString(16), z3.toString(10).slice(2));
             }
        })

        it.only('Jacobian Double', async () => {
            // Test data generated by golang crypto/elliptic library
            var ECADD_TEST_DATA = require('./data/double-jacobian.json');

            let fixture;
            for (var i in ECADD_TEST_DATA) {
                fixture = ECADD_TEST_DATA[i];

                // get inputs
                const x1 = toBigNumber(new BigNumber(fixture['input'][0], 16));
                const y1 = toBigNumber(new BigNumber(fixture['input'][1], 16));
                const z1 = toBigNumber(new BigNumber(fixture['input'][2], 16));

                // expected outputs
                const x3 = toBigNumber(new BigNumber(fixture['output'][0], 16));
                const y3 = toBigNumber(new BigNumber(fixture['output'][1], 16));
                const z3 = toBigNumber(new BigNumber(fixture['output'][2], 16));

                let P = [x1, y1, z1];

                let res = await secp256r1._jDouble(P[0], P[1], P[2]);
                assert.equal(res[0].toString(16), x3.toString(10).slice(2));
                assert.equal(res[1].toString(16), y3.toString(10).slice(2));
                assert.equal(res[2].toString(16), z3.toString(10).slice(2));
             }
        })
    })
});
